/* File autogenerated with svd2groov_multi */
#pragma once

#include <groov/groov.hpp>

#include <stm32/common/access.hpp>

namespace stm32::registers {

// OTFDEC peripheral register templates
// Total unique registers: 35

// otfdec_cr_v1: CR (version 1)
// Used by: OTFDEC1.CR@stm32h7b0x, OTFDEC2.CR@stm32h7b0x, OTFDEC1.CR@stm32h7b3x, OTFDEC2.CR@stm32h7b3x, OTFDEC1.CR@stm32l562, ... +9 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_cr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reserved0", std::uint32_t, 31, 1, access::ro>,
             groov::field<"enc", bool, 0, 0>>;

// otfdec_icr_v1: ICR (version 1)
// Used by: OTFDEC1.ICR@stm32h7b0x, OTFDEC2.ICR@stm32h7b0x, OTFDEC1.ICR@stm32h7b3x, OTFDEC2.ICR@stm32h7b3x, OTFDEC1.ICR@stm32u59x, ... +7 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_icr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::ro,
             groov::field<"reserved0", std::uint32_t, 31, 3>,
             groov::field<"keif", bool, 2, 2>,
             groov::field<"xoneif", bool, 1, 1>,
             groov::field<"seif", bool, 0, 0>>;

// otfdec_icr_v2: ICR (version 2)
// Used by: OTFDEC1.ICR@stm32l562, SEC_OTFDEC1.ICR@stm32l562
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_icr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"reserved0", std::uint32_t, 31, 3, access::ro>,
             groov::field<"keif", bool, 2, 2>,
             groov::field<"xoneif", bool, 1, 1>,
             groov::field<"seif", bool, 0, 0>>;

// otfdec_ier_v1: IER (version 1)
// Used by: OTFDEC1.IER@stm32h7b0x, OTFDEC2.IER@stm32h7b0x, OTFDEC1.IER@stm32h7b3x, OTFDEC2.IER@stm32h7b3x, OTFDEC1.IER@stm32l562, ... +9 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_ier_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reserved0", std::uint32_t, 31, 3, access::ro>,
             groov::field<"keie", bool, 2, 2>,
             groov::field<"xoneie", bool, 1, 1>,
             groov::field<"seie", bool, 0, 0>>;

// otfdec_otfdec_icr_v1: OTFDEC_ICR (version 1)
// Used by: OTFDEC1.OTFDEC_ICR@stm32h725, OTFDEC2.OTFDEC_ICR@stm32h725, OTFDEC1.OTFDEC_ICR@stm32h73x, OTFDEC2.OTFDEC_ICR@stm32h73x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_otfdec_icr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reserved0", std::uint32_t, 31, 3, access::ro>,
             groov::field<"keif", bool, 2, 2, access::wo>,
             groov::field<"xoneif", bool, 1, 1, access::wo>,
             groov::field<"seif", bool, 0, 0, access::wo>>;

// otfdec_otfdec_isr_v1: OTFDEC_ISR (version 1)
// Used by: OTFDEC1.OTFDEC_ISR@stm32h725, OTFDEC2.OTFDEC_ISR@stm32h725, OTFDEC1.OTFDEC_ISR@stm32h73x, OTFDEC2.OTFDEC_ISR@stm32h73x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_otfdec_isr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reserved0", std::uint32_t, 31, 3, access::ro>,
             groov::field<"keif", bool, 2, 2, access::ro>,
             groov::field<"xoneif", bool, 1, 1, access::ro>,
             groov::field<"seif", bool, 0, 0, access::ro>>;

// otfdec_otfdec_r4keyr3_v1: OTFDEC_R4KEYR3 (version 1)
// Used by: OTFDEC1.OTFDEC_R4KEYR3@stm32h725, OTFDEC2.OTFDEC_R4KEYR3@stm32h725, OTFDEC1.OTFDEC_R4KEYR3@stm32h73x, OTFDEC2.OTFDEC_R4KEYR3@stm32h73x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_otfdec_r4keyr3_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"regx_key", std::uint32_t, 31, 0, access::wo>>;

// otfdec_privcfgr_v1: PRIVCFGR (version 1)
// Used by: OTFDEC1.PRIVCFGR@stm32u59x, SEC_OTFDEC1.PRIVCFGR@stm32u59x, OTFDEC2.PRIVCFGR@stm32u59x, SEC_OTFDEC2.PRIVCFGR@stm32u59x, OTFDEC1.PRIVCFGR@stm32u5xx, ... +3 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_privcfgr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reserved0", std::uint32_t, 31, 1, access::ro>,
             groov::field<"priv", bool, 0, 0>>;

// otfdec_r1cfgr_v2: R1CFGR (version 2)
// Used by: OTFDEC1.R1CFGR@stm32u59x, SEC_OTFDEC1.R1CFGR@stm32u59x, OTFDEC2.R1CFGR@stm32u59x, SEC_OTFDEC2.R1CFGR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r1cfgr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg1_version", std::uint16_t, 31, 16>,
             groov::field<"keycrc", std::uint8_t, 15, 8, access::ro>,
             groov::field<"reserved1", std::uint8_t, 7, 6, access::ro>,
             groov::field<"mode", std::uint8_t, 5, 4>,
             groov::field<"reserved0", bool, 3, 3, access::ro>,
             groov::field<"keylock", bool, 2, 2>,
             groov::field<"configlock", bool, 1, 1>,
             groov::field<"reg_en", bool, 0, 0>>;

// otfdec_r1endaddr_v2: R1ENDADDR (version 2)
// Used by: OTFDEC1.R1ENDADDR@stm32u59x, SEC_OTFDEC1.R1ENDADDR@stm32u59x, OTFDEC2.R1ENDADDR@stm32u59x, SEC_OTFDEC2.R1ENDADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r1endaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg1_end_addr", std::uint32_t, 31, 0>>;

// otfdec_r1keyr3_v2: R1KEYR3 (version 2)
// Used by: OTFDEC1.R1KEYR3@stm32u59x, SEC_OTFDEC1.R1KEYR3@stm32u59x, OTFDEC2.R1KEYR3@stm32u59x, SEC_OTFDEC2.R1KEYR3@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r1keyr3_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"reg1_key", std::uint32_t, 31, 0>>;

// otfdec_r1noncer1_v2: R1NONCER1 (version 2)
// Used by: OTFDEC1.R1NONCER1@stm32u59x, SEC_OTFDEC1.R1NONCER1@stm32u59x, OTFDEC2.R1NONCER1@stm32u59x, SEC_OTFDEC2.R1NONCER1@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r1noncer1_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg1_nonce", std::uint32_t, 31, 0>>;

// otfdec_r1startaddr_v2: R1STARTADDR (version 2)
// Used by: OTFDEC1.R1STARTADDR@stm32u59x, SEC_OTFDEC1.R1STARTADDR@stm32u59x, OTFDEC2.R1STARTADDR@stm32u59x, SEC_OTFDEC2.R1STARTADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r1startaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg1_start_addr", std::uint32_t, 31, 0>>;

// otfdec_r2cfgr_v2: R2CFGR (version 2)
// Used by: OTFDEC1.R2CFGR@stm32u59x, SEC_OTFDEC1.R2CFGR@stm32u59x, OTFDEC2.R2CFGR@stm32u59x, SEC_OTFDEC2.R2CFGR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r2cfgr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg2_version", std::uint16_t, 31, 16>,
             groov::field<"keycrc", std::uint8_t, 15, 8, access::ro>,
             groov::field<"reserved1", std::uint8_t, 7, 6, access::ro>,
             groov::field<"mode", std::uint8_t, 5, 4>,
             groov::field<"reserved0", bool, 3, 3, access::ro>,
             groov::field<"keylock", bool, 2, 2>,
             groov::field<"configlock", bool, 1, 1>,
             groov::field<"reg_en", bool, 0, 0>>;

// otfdec_r2endaddr_v2: R2ENDADDR (version 2)
// Used by: OTFDEC1.R2ENDADDR@stm32u59x, SEC_OTFDEC1.R2ENDADDR@stm32u59x, OTFDEC2.R2ENDADDR@stm32u59x, SEC_OTFDEC2.R2ENDADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r2endaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg2_end_addr", std::uint32_t, 31, 0>>;

// otfdec_r2keyr2_v1: R2KEYR2 (version 1)
// Used by: OTFDEC1.R2KEYR2@stm32h7b0x, OTFDEC2.R2KEYR2@stm32h7b0x, OTFDEC1.R2KEYR2@stm32h7b3x, OTFDEC2.R2KEYR2@stm32h7b3x, OTFDEC1.R2KEYR2@stm32l562, ... +5 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r2keyr2_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"regx_key_", std::uint32_t, 31, 0>>;

// otfdec_r2keyr2_v2: R2KEYR2 (version 2)
// Used by: OTFDEC1.R2KEYR2@stm32u59x, SEC_OTFDEC1.R2KEYR2@stm32u59x, OTFDEC2.R2KEYR2@stm32u59x, SEC_OTFDEC2.R2KEYR2@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r2keyr2_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"reg2_key_", std::uint32_t, 31, 0>>;

// otfdec_r2keyr3_v2: R2KEYR3 (version 2)
// Used by: OTFDEC1.R2KEYR3@stm32u59x, SEC_OTFDEC1.R2KEYR3@stm32u59x, OTFDEC2.R2KEYR3@stm32u59x, SEC_OTFDEC2.R2KEYR3@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r2keyr3_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"reg2_key", std::uint32_t, 31, 0>>;

// otfdec_r2noncer1_v2: R2NONCER1 (version 2)
// Used by: OTFDEC1.R2NONCER1@stm32u59x, SEC_OTFDEC1.R2NONCER1@stm32u59x, OTFDEC2.R2NONCER1@stm32u59x, SEC_OTFDEC2.R2NONCER1@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r2noncer1_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg2_nonce", std::uint32_t, 31, 0>>;

// otfdec_r2startaddr_v2: R2STARTADDR (version 2)
// Used by: OTFDEC1.R2STARTADDR@stm32u59x, SEC_OTFDEC1.R2STARTADDR@stm32u59x, OTFDEC2.R2STARTADDR@stm32u59x, SEC_OTFDEC2.R2STARTADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r2startaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg2_start_addr", std::uint32_t, 31, 0>>;

// otfdec_r3cfgr_v2: R3CFGR (version 2)
// Used by: OTFDEC1.R3CFGR@stm32u59x, SEC_OTFDEC1.R3CFGR@stm32u59x, OTFDEC2.R3CFGR@stm32u59x, SEC_OTFDEC2.R3CFGR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r3cfgr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg3_version", std::uint16_t, 31, 16>,
             groov::field<"keycrc", std::uint8_t, 15, 8, access::ro>,
             groov::field<"reserved1", std::uint8_t, 7, 6, access::ro>,
             groov::field<"mode", std::uint8_t, 5, 4>,
             groov::field<"reserved0", bool, 3, 3, access::ro>,
             groov::field<"keylock", bool, 2, 2>,
             groov::field<"configlock", bool, 1, 1>,
             groov::field<"reg_en", bool, 0, 0>>;

// otfdec_r3endaddr_v2: R3ENDADDR (version 2)
// Used by: OTFDEC1.R3ENDADDR@stm32u59x, SEC_OTFDEC1.R3ENDADDR@stm32u59x, OTFDEC2.R3ENDADDR@stm32u59x, SEC_OTFDEC2.R3ENDADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r3endaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg3_end_addr", std::uint32_t, 31, 0>>;

// otfdec_r3keyr3_v2: R3KEYR3 (version 2)
// Used by: OTFDEC1.R3KEYR3@stm32u59x, SEC_OTFDEC1.R3KEYR3@stm32u59x, OTFDEC2.R3KEYR3@stm32u59x, SEC_OTFDEC2.R3KEYR3@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r3keyr3_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"reg3_key", std::uint32_t, 31, 0>>;

// otfdec_r3noncer1_v2: R3NONCER1 (version 2)
// Used by: OTFDEC1.R3NONCER1@stm32u59x, SEC_OTFDEC1.R3NONCER1@stm32u59x, OTFDEC2.R3NONCER1@stm32u59x, SEC_OTFDEC2.R3NONCER1@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r3noncer1_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg3_nonce", std::uint32_t, 31, 0>>;

// otfdec_r3startaddr_v2: R3STARTADDR (version 2)
// Used by: OTFDEC1.R3STARTADDR@stm32u59x, SEC_OTFDEC1.R3STARTADDR@stm32u59x, OTFDEC2.R3STARTADDR@stm32u59x, SEC_OTFDEC2.R3STARTADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r3startaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg3_start_addr", std::uint32_t, 31, 0>>;

// otfdec_r4cfgr_v1: R4CFGR (version 1)
// Used by: OTFDEC1.R4CFGR@stm32h7b0x, OTFDEC2.R4CFGR@stm32h7b0x, OTFDEC1.R4CFGR@stm32h7b3x, OTFDEC2.R4CFGR@stm32h7b3x, OTFDEC1.R4CFGR@stm32l562, ... +5 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4cfgr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"regx_version", std::uint16_t, 31, 16>,
             groov::field<"keycrc", std::uint8_t, 15, 8, access::ro>,
             groov::field<"reserved1", std::uint8_t, 7, 6, access::ro>,
             groov::field<"mode", std::uint8_t, 5, 4>,
             groov::field<"reserved0", bool, 3, 3, access::ro>,
             groov::field<"keylock", bool, 2, 2>,
             groov::field<"configlock", bool, 1, 1>,
             groov::field<"reg_en", bool, 0, 0>>;

// otfdec_r4cfgr_v2: R4CFGR (version 2)
// Used by: OTFDEC1.R4CFGR@stm32u59x, SEC_OTFDEC1.R4CFGR@stm32u59x, OTFDEC2.R4CFGR@stm32u59x, SEC_OTFDEC2.R4CFGR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4cfgr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg4_version", std::uint16_t, 31, 16>,
             groov::field<"keycrc", std::uint8_t, 15, 8, access::ro>,
             groov::field<"reserved1", std::uint8_t, 7, 6, access::ro>,
             groov::field<"mode", std::uint8_t, 5, 4>,
             groov::field<"reserved0", bool, 3, 3, access::ro>,
             groov::field<"keylock", bool, 2, 2>,
             groov::field<"configlock", bool, 1, 1>,
             groov::field<"reg_en", bool, 0, 0>>;

// otfdec_r4endaddr_v1: R4ENDADDR (version 1)
// Used by: OTFDEC1.R4ENDADDR@stm32h7b0x, OTFDEC2.R4ENDADDR@stm32h7b0x, OTFDEC1.R4ENDADDR@stm32h7b3x, OTFDEC2.R4ENDADDR@stm32h7b3x, OTFDEC1.R4ENDADDR@stm32l562, ... +5 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4endaddr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"regx_end_addr", std::uint32_t, 31, 0>>;

// otfdec_r4endaddr_v2: R4ENDADDR (version 2)
// Used by: OTFDEC1.R4ENDADDR@stm32u59x, SEC_OTFDEC1.R4ENDADDR@stm32u59x, OTFDEC2.R4ENDADDR@stm32u59x, SEC_OTFDEC2.R4ENDADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4endaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg4_end_addr", std::uint32_t, 31, 0>>;

// otfdec_r4keyr3_v1: R4KEYR3 (version 1)
// Used by: OTFDEC1.R4KEYR3@stm32h7b0x, OTFDEC2.R4KEYR3@stm32h7b0x, OTFDEC1.R4KEYR3@stm32h7b3x, OTFDEC2.R4KEYR3@stm32h7b3x, OTFDEC1.R4KEYR3@stm32l562, ... +5 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4keyr3_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"regx_key", std::uint32_t, 31, 0>>;

// otfdec_r4keyr3_v2: R4KEYR3 (version 2)
// Used by: OTFDEC1.R4KEYR3@stm32u59x, SEC_OTFDEC1.R4KEYR3@stm32u59x, OTFDEC2.R4KEYR3@stm32u59x, SEC_OTFDEC2.R4KEYR3@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4keyr3_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::wo,
             groov::field<"reg4_key", std::uint32_t, 31, 0>>;

// otfdec_r4noncer1_v1: R4NONCER1 (version 1)
// Used by: OTFDEC1.R4NONCER1@stm32h7b0x, OTFDEC2.R4NONCER1@stm32h7b0x, OTFDEC1.R4NONCER1@stm32h7b3x, OTFDEC2.R4NONCER1@stm32h7b3x, OTFDEC1.R4NONCER1@stm32l562, ... +5 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4noncer1_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"regx_nonce", std::uint32_t, 31, 0>>;

// otfdec_r4noncer1_v2: R4NONCER1 (version 2)
// Used by: OTFDEC1.R4NONCER1@stm32u59x, SEC_OTFDEC1.R4NONCER1@stm32u59x, OTFDEC2.R4NONCER1@stm32u59x, SEC_OTFDEC2.R4NONCER1@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4noncer1_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg4_nonce", std::uint32_t, 31, 0>>;

// otfdec_r4startaddr_v1: R4STARTADDR (version 1)
// Used by: OTFDEC1.R4STARTADDR@stm32h7b0x, OTFDEC2.R4STARTADDR@stm32h7b0x, OTFDEC1.R4STARTADDR@stm32h7b3x, OTFDEC2.R4STARTADDR@stm32h7b3x, OTFDEC1.R4STARTADDR@stm32l562, ... +5 more
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4startaddr_v1_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"regx_start_addr", std::uint32_t, 31, 0>>;

// otfdec_r4startaddr_v2: R4STARTADDR (version 2)
// Used by: OTFDEC1.R4STARTADDR@stm32u59x, SEC_OTFDEC1.R4STARTADDR@stm32u59x, OTFDEC2.R4STARTADDR@stm32u59x, SEC_OTFDEC2.R4STARTADDR@stm32u59x
template <stdx::ct_string name,
          std::uint32_t   baseaddress,
          std::uint32_t   offset>
using otfdec_r4startaddr_v2_tt =
  groov::reg<name,
             std::uint32_t,
             baseaddress + offset,
             access::rw,
             groov::field<"reg4_start_addr", std::uint32_t, 31, 0>>;

} // namespace stm32::registers
