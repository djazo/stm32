#!/usr/bin/env python3
"""
Generate stm32/config.hpp and stm32/stm32.hpp from a CubeMX .ioc file.

Called by meson as a custom_target:
  gen_config.py <ioc_file> <output_dir>

Writes:
  <output_dir>/config.hpp  - peripheral enable/disable flags
  <output_dir>/stm32.hpp   - single include that pulls in the MCU header

Parses the .ioc file for:
  - Mcu.CPN  -> MCU identity (maps to MCU name via ioc2mcu)
  - Mcu.IP*  -> enabled peripherals

Reads the pre-generated addresses.hpp for the full peripheral list.

Prints the MCU name to stdout so meson can capture it.
"""

import argparse
import re
import sys
from pathlib import Path

# Import helpers from sibling scripts
sys.path.insert(0, str(Path(__file__).parent))
from ioc2mcu import cpn_to_mcu


def parse_ioc(ioc_path: str) -> dict[str, str]:
    """Parse a .ioc file into a key-value dict."""
    result = {}
    for line in Path(ioc_path).read_text().splitlines():
        line = line.strip()
        if '=' in line and not line.startswith('#'):
            key, _, value = line.partition('=')
            result[key] = value
    return result


def extract_enabled_peripherals(ioc: dict[str, str]) -> set[str]:
    """Extract the set of enabled peripheral names (lowercased) from .ioc."""
    enabled = set()
    i = 0
    while True:
        key = f'Mcu.IP{i}'
        if key not in ioc:
            break
        enabled.add(ioc[key].lower())
        i += 1
    return enabled


_ADDR_NS_RE = re.compile(r'^namespace (\w+) \{')


def list_peripherals_from_addresses(addresses_path: Path) -> list[str]:
    """Extract sorted peripheral names from a generated addresses.hpp."""
    names = []
    for line in addresses_path.read_text().splitlines():
        m = _ADDR_NS_RE.match(line)
        if m:
            names.append(m.group(1))
    return sorted(names)


def main():
    parser = argparse.ArgumentParser(
        description='Generate stm32/config.hpp from .ioc file'
    )
    parser.add_argument('ioc_file', help='Input CubeMX .ioc file')
    parser.add_argument('output_dir', help='Output directory')

    args = parser.parse_args()

    ioc = parse_ioc(args.ioc_file)

    # Determine MCU name from CPN
    cpn = ioc.get('Mcu.CPN')
    if not cpn:
        print("Error: Mcu.CPN not found in .ioc file", file=sys.stderr)
        sys.exit(1)

    mcu = cpn_to_mcu(cpn)

    # Locate pre-generated addresses.hpp
    project_root = Path(__file__).parent.parent
    addresses_path = (project_root / 'include' / 'stm32' /
                      mcu / 'peripherals' / 'addresses.hpp')
    if not addresses_path.exists():
        print(f"Error: addresses.hpp not found: {addresses_path}",
              file=sys.stderr)
        sys.exit(1)

    # Get enabled peripherals from .ioc
    enabled_ips = extract_enabled_peripherals(ioc)

    # Get all peripherals from pre-generated headers
    all_peripherals = list_peripherals_from_addresses(addresses_path)

    out_dir = Path(args.output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Generate config.hpp
    lines = []
    lines.append('/* File autogenerated by meson - do not edit */')
    lines.append('#pragma once')
    lines.append('')
    lines.append(f'namespace stm32::{mcu}::config {{')

    for p in all_peripherals:
        # Match directly, or match .ioc name without instance number
        # e.g. .ioc "can" matches SVD "can1", "can2"
        matched = p in enabled_ips or any(
            p == ip or re.fullmatch(rf'{re.escape(ip)}\d+', p)
            for ip in enabled_ips
        )
        enabled = 'true' if matched else 'false'
        lines.append(f'inline constexpr bool {p} = {enabled};')

    lines.append('')
    lines.append(f'}} // namespace stm32::{mcu}::config')
    lines.append('')

    (out_dir / 'config.hpp').write_text('\n'.join(lines))

    # Generate stm32.hpp
    stm32_lines = []
    stm32_lines.append('/* File autogenerated by meson - do not edit */')
    stm32_lines.append('#pragma once')
    stm32_lines.append('')
    stm32_lines.append(f'#include <stm32/{mcu}/{mcu}.hpp>')
    stm32_lines.append('')

    (out_dir / 'stm32.hpp').write_text('\n'.join(stm32_lines))

    # Print MCU name to stdout for meson to capture
    print(mcu)


if __name__ == '__main__':
    main()
